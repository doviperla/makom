!(function (O, z, A, w) {
  z = void 0 !== z && z.Math == Math ? z : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), O.fn.visibility = function (h) {
    let P,
      e = O(this),
      x = e.selector || '',
      C = (new Date()).getTime(),
      y = [],
      S = h,
      R = typeof S === 'string',
      V = [].slice.call(arguments, 1),
      k = e.length,
      T = 0; return e.each(function () {
        let e,
          o,
          n,
          r,
          i = O.isPlainObject(h) ? O.extend(!0, {}, O.fn.visibility.settings, h) : O.extend({}, O.fn.visibility.settings),
          t = i.className,
          s = i.namespace,
          a = i.error,
          c = i.metadata,
          l = `.${s}`,
          d = `module-${s}`,
          u = O(z),
          f = O(this),
          b = O(i.context),
          g = (f.selector, f.data(d)),
          m = z.requestAnimationFrame || z.mozRequestAnimationFrame || z.webkitRequestAnimationFrame || z.msRequestAnimationFrame || function (e) { setTimeout(e, 0); },
          p = this,
          v = !1; r = { initialize() { r.debug('Initializing', i), r.setup.cache(), r.should.trackChanges() && (i.type == 'image' && r.setup.image(), i.type == 'fixed' && r.setup.fixed(), i.observeChanges && r.observeChanges(), r.bind.events()), r.save.position(), r.is.visible() || r.error(a.visible, f), i.initialCheck && r.checkVisibility(), r.instantiate(); },
            instantiate() { r.debug('Storing instance', r), f.data(d, r), g = r; },
            destroy() { r.verbose('Destroying previous module'), n && n.disconnect(), o && o.disconnect(), u.off(`load${l}`, r.event.load).off(`resize${l}`, r.event.resize), b.off(`scroll${l}`, r.event.scroll).off(`scrollchange${l}`, r.event.scrollchange), i.type == 'fixed' && (r.resetFixed(), r.remove.placeholder()), f.off(l).removeData(d); },
            observeChanges() { 'MutationObserver' in z && (o = new MutationObserver(r.event.contextChanged), n = new MutationObserver(r.event.changed), o.observe(A, { childList: !0, subtree: !0 }), n.observe(p, { childList: !0, subtree: !0 }), r.debug('Setting up mutation observer', n)); },
            bind: { events() { r.verbose('Binding visibility events to scroll and resize'), i.refreshOnLoad && u.on(`load${l}`, r.event.load), u.on(`resize${l}`, r.event.resize), b.off(`scroll${l}`).on(`scroll${l}`, r.event.scroll).on(`scrollchange${l}`, r.event.scrollchange); } },
            event: { changed(e) { r.verbose('DOM tree modified, updating visibility calculations'), r.timer = setTimeout(() => { r.verbose('DOM tree modified, updating sticky menu'), r.refresh(); }, 100); }, contextChanged(e) { [].forEach.call(e, (e) => { e.removedNodes && [].forEach.call(e.removedNodes, (e) => { (e == p || O(e).find(p).length > 0) && (r.debug('Element removed from DOM, tearing down events'), r.destroy()); }); }); }, resize() { r.debug('Window resized'), i.refreshOnResize && m(r.refresh); }, load() { r.debug('Page finished loading'), m(r.refresh); }, scroll() { i.throttle ? (clearTimeout(r.timer), r.timer = setTimeout(() => { b.triggerHandler(`scrollchange${l}`, [b.scrollTop()]); }, i.throttle)) : m(() => { b.triggerHandler(`scrollchange${l}`, [b.scrollTop()]); }); }, scrollchange(e, o) { r.checkVisibility(o); } },
            precache(e, o) { e instanceof Array || (e = [e]); for (var n = e.length, t = 0, i = [], s = A.createElement('img'), c = function () { ++t >= e.length && O.isFunction(o) && o(); }; n--;)(s = A.createElement('img')).onload = c, s.onerror = c, s.src = e[n], i.push(s); },
            enableCallbacks() { r.debug('Allowing callbacks to occur'), v = !1; },
            disableCallbacks() { r.debug('Disabling all callbacks temporarily'), v = !0; },
            should: { trackChanges() { return R ? (r.debug('One time query, no need to bind events'), !1) : (r.debug('Callbacks being attached'), !0); } },
            setup: { cache() { r.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = f.data(c.src); e && (r.verbose('Lazy loading image', e), i.once = !0, i.observeChanges = !1, i.onOnScreen = function () { r.debug('Image on screen', p), r.precache(e, () => { r.set.image(e, function () { ++T == k && i.onAllLoaded.call(this), i.onLoad.call(this); }); }); }); }, fixed() { r.debug('Setting up fixed'), i.once = !1, i.observeChanges = !1, i.initialCheck = !0, i.refreshOnLoad = !0, h.transition || (i.transition = !1), r.create.placeholder(), r.debug('Added placeholder', e), i.onTopPassed = function () { r.debug('Element passed, adding fixed position', f), r.show.placeholder(), r.set.fixed(), i.transition && O.fn.transition !== w && f.transition(i.transition, i.duration); }, i.onTopPassedReverse = function () { r.debug('Element returned to position, removing fixed', f), r.hide.placeholder(), r.remove.fixed(); }; } },
            create: { placeholder() { r.verbose('Creating fixed position placeholder'), e = f.clone(!1).css('display', 'none').addClass(t.placeholder).insertAfter(f); } },
            show: { placeholder() { r.verbose('Showing placeholder'), e.css('display', 'block').css('visibility', 'hidden'); } },
            hide: { placeholder() { r.verbose('Hiding placeholder'), e.css('display', 'none').css('visibility', ''); } },
            set: { fixed() { r.verbose('Setting element to fixed position'), f.addClass(t.fixed).css({ position: 'fixed', top: `${i.offset}px`, left: 'auto', zIndex: i.zIndex }), i.onFixed.call(p); }, image(e, o) { if (f.attr('src', e), i.transition) if (O.fn.transition !== w) { if (f.hasClass(t.visible)) return void r.debug('Transition already occurred on this image, skipping animation'); f.transition(i.transition, i.duration, o); } else f.fadeIn(i.duration, o); else f.show(); } },
            is: { onScreen() { return r.get.elementCalculations().onScreen; }, offScreen() { return r.get.elementCalculations().offScreen; }, visible() { return !(!r.cache || !r.cache.element) && !(r.cache.element.width === 0 && r.cache.element.offset.top === 0); }, verticallyScrollableContext() { const e = b.get(0) !== z && b.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = b.get(0) !== z && b.css('overflow-x'); return e == 'auto' || e == 'scroll'; } },
            refresh() { r.debug('Refreshing constants (width/height)'), i.type == 'fixed' && r.resetFixed(), r.reset(), r.save.position(), i.checkOnRefresh && r.checkVisibility(), i.onRefresh.call(p); },
            resetFixed() { r.remove.fixed(), r.remove.occurred(); },
            reset() { r.verbose('Resetting all cached values'), O.isPlainObject(r.cache) && (r.cache.screen = {}, r.cache.element = {}); },
            checkVisibility(e) { r.verbose('Checking visibility of element', r.cache.element), !v && r.is.visible() && (r.save.scroll(e), r.save.calculations(), r.passed(), r.passingReverse(), r.topVisibleReverse(), r.bottomVisibleReverse(), r.topPassedReverse(), r.bottomPassedReverse(), r.onScreen(), r.offScreen(), r.passing(), r.topVisible(), r.bottomVisible(), r.topPassed(), r.bottomPassed(), i.onUpdate && i.onUpdate.call(p, r.get.elementCalculations())); },
            passed(e, o) { const n = r.get.elementCalculations(); if (e && o)i.onPassed[e] = o; else { if (e !== w) return r.get.pixelsPassed(e) > n.pixelsPassed; n.passing && O.each(i.onPassed, (e, o) => { n.bottomVisible || n.pixelsPassed > r.get.pixelsPassed(e) ? r.execute(o, e) : i.once || r.remove.occurred(o); }); } },
            onScreen(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onOnScreen,
                t = 'onScreen'; if (e && (r.debug('Adding callback for onScreen', e), i.onOnScreen = e), o.onScreen ? r.execute(n, t) : i.once || r.remove.occurred(t), e !== w) return o.onOnScreen;
            },
            offScreen(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onOffScreen,
                t = 'offScreen'; if (e && (r.debug('Adding callback for offScreen', e), i.onOffScreen = e), o.offScreen ? r.execute(n, t) : i.once || r.remove.occurred(t), e !== w) return o.onOffScreen;
            },
            passing(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onPassing,
                t = 'passing'; if (e && (r.debug('Adding callback for passing', e), i.onPassing = e), o.passing ? r.execute(n, t) : i.once || r.remove.occurred(t), e !== w) return o.passing;
            },
            topVisible(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onTopVisible,
                t = 'topVisible'; if (e && (r.debug('Adding callback for top visible', e), i.onTopVisible = e), o.topVisible ? r.execute(n, t) : i.once || r.remove.occurred(t), e === w) return o.topVisible;
            },
            bottomVisible(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onBottomVisible,
                t = 'bottomVisible'; if (e && (r.debug('Adding callback for bottom visible', e), i.onBottomVisible = e), o.bottomVisible ? r.execute(n, t) : i.once || r.remove.occurred(t), e === w) return o.bottomVisible;
            },
            topPassed(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onTopPassed,
                t = 'topPassed'; if (e && (r.debug('Adding callback for top passed', e), i.onTopPassed = e), o.topPassed ? r.execute(n, t) : i.once || r.remove.occurred(t), e === w) return o.topPassed;
            },
            bottomPassed(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onBottomPassed,
                t = 'bottomPassed'; if (e && (r.debug('Adding callback for bottom passed', e), i.onBottomPassed = e), o.bottomPassed ? r.execute(n, t) : i.once || r.remove.occurred(t), e === w) return o.bottomPassed;
            },
            passingReverse(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onPassingReverse,
                t = 'passingReverse'; if (e && (r.debug('Adding callback for passing reverse', e), i.onPassingReverse = e), o.passing ? i.once || r.remove.occurred(t) : r.get.occurred('passing') && r.execute(n, t), e !== w) return !o.passing;
            },
            topVisibleReverse(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onTopVisibleReverse,
                t = 'topVisibleReverse'; if (e && (r.debug('Adding callback for top visible reverse', e), i.onTopVisibleReverse = e), o.topVisible ? i.once || r.remove.occurred(t) : r.get.occurred('topVisible') && r.execute(n, t), e === w) return !o.topVisible;
            },
            bottomVisibleReverse(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onBottomVisibleReverse,
                t = 'bottomVisibleReverse'; if (e && (r.debug('Adding callback for bottom visible reverse', e), i.onBottomVisibleReverse = e), o.bottomVisible ? i.once || r.remove.occurred(t) : r.get.occurred('bottomVisible') && r.execute(n, t), e === w) return !o.bottomVisible;
            },
            topPassedReverse(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onTopPassedReverse,
                t = 'topPassedReverse'; if (e && (r.debug('Adding callback for top passed reverse', e), i.onTopPassedReverse = e), o.topPassed ? i.once || r.remove.occurred(t) : r.get.occurred('topPassed') && r.execute(n, t), e === w) return !o.onTopPassed;
            },
            bottomPassedReverse(e) {
              let o = r.get.elementCalculations(),
                n = e || i.onBottomPassedReverse,
                t = 'bottomPassedReverse'; if (e && (r.debug('Adding callback for bottom passed reverse', e), i.onBottomPassedReverse = e), o.bottomPassed ? i.once || r.remove.occurred(t) : r.get.occurred('bottomPassed') && r.execute(n, t), e === w) return !o.bottomPassed;
            },
            execute(e, o) {
              let n = r.get.elementCalculations(),
                t = r.get.screenCalculations(); (e = e || !1) && (i.continuous ? (r.debug('Callback being called continuously', o, n), e.call(p, n, t)) : r.get.occurred(o) || (r.debug('Conditions met', o, n), e.call(p, n, t))), r.save.occurred(o);
            },
            remove: { fixed() { r.debug('Removing fixed position'), f.removeClass(t.fixed).css({ position: '', top: '', left: '', zIndex: '' }), i.onUnfixed.call(p); }, placeholder() { r.debug('Removing placeholder content'), e && e.remove(); }, occurred(e) { if (e) { const o = r.cache.occurred; o[e] !== w && !0 === o[e] && (r.debug('Callback can now be called again', e), r.cache.occurred[e] = !1); } else r.cache.occurred = {}; } },
            save: { calculations() { r.verbose('Saving all calculations necessary to determine positioning'), r.save.direction(), r.save.screenCalculations(), r.save.elementCalculations(); },
              occurred(e) { e && (r.cache.occurred[e] !== w && !0 === r.cache.occurred[e] || (r.verbose('Saving callback occurred', e), r.cache.occurred[e] = !0)); },
              scroll(e) { e = e + i.offset || b.scrollTop() + i.offset, r.cache.scroll = e; },
              direction() {
                let e,
                  o = r.get.scroll(),
                  n = r.get.lastScroll(); return e = n < o && n ? 'down' : o < n && n ? 'up' : 'static', r.cache.direction = e, r.cache.direction;
              },
              elementPosition() {
                let e = r.cache.element,
                  o = r.get.screenSize(); return r.verbose('Saving element position'), e.fits = e.height < o.height, e.offset = f.offset(), e.width = f.outerWidth(), e.height = f.outerHeight(), r.is.verticallyScrollableContext() && (e.offset.top += b.scrollTop() - b.offset().top), r.is.horizontallyScrollableContext() && (e.offset.left += b.scrollLeft - b.offset().left), r.cache.element = e;
              },
              elementCalculations() {
                let e = r.get.screenCalculations(),
                  o = r.get.elementPosition(); return i.includeMargin ? (o.margin = {}, o.margin.top = parseInt(f.css('margin-top'), 10), o.margin.bottom = parseInt(f.css('margin-bottom'), 10), o.top = o.offset.top - o.margin.top, o.bottom = o.offset.top + o.height + o.margin.bottom) : (o.top = o.offset.top, o.bottom = o.offset.top + o.height), o.topPassed = e.top >= o.top, o.bottomPassed = e.top >= o.bottom, o.topVisible = e.bottom >= o.top && !o.topPassed, o.bottomVisible = e.bottom >= o.bottom && !o.bottomPassed, o.pixelsPassed = 0, o.percentagePassed = 0, o.onScreen = (o.topVisible || o.passing) && !o.bottomPassed, o.passing = o.topPassed && !o.bottomPassed, o.offScreen = !o.onScreen, o.passing && (o.pixelsPassed = e.top - o.top, o.percentagePassed = (e.top - o.top) / o.height), r.cache.element = o, r.verbose('Updated element calculations', o), o;
              },
              screenCalculations() { const e = r.get.scroll(); return r.save.direction(), r.cache.screen.top = e, r.cache.screen.bottom = e + r.cache.screen.height, r.cache.screen; },
              screenSize() { r.verbose('Saving window position'), r.cache.screen = { height: b.height() }; },
              position() { r.save.screenSize(), r.save.elementPosition(); } },
            get: { pixelsPassed(e) { const o = r.get.elementCalculations(); return e.search('%') > -1 ? o.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return r.cache.occurred !== w && r.cache.occurred[e] || !1; }, direction() { return r.cache.direction === w && r.save.direction(), r.cache.direction; }, elementPosition() { return r.cache.element === w && r.save.elementPosition(), r.cache.element; }, elementCalculations() { return r.cache.element === w && r.save.elementCalculations(), r.cache.element; }, screenCalculations() { return r.cache.screen === w && r.save.screenCalculations(), r.cache.screen; }, screenSize() { return r.cache.screen === w && r.save.screenSize(), r.cache.screen; }, scroll() { return r.cache.scroll === w && r.save.scroll(), r.cache.scroll; }, lastScroll() { return r.cache.screen === w ? (r.debug('First scroll event, no last scroll could be found'), !1) : r.cache.screen.top; } },
            setting(e, o) { if (O.isPlainObject(e))O.extend(!0, i, e); else { if (o === w) return i[e]; i[e] = o; } },
            internal(e, o) { if (O.isPlainObject(e))O.extend(!0, r, e); else { if (o === w) return r[e]; r[e] = o; } },
            debug() { !i.silent && i.debug && (i.performance ? r.performance.log(arguments) : (r.debug = Function.prototype.bind.call(console.info, console, `${i.name}:`), r.debug.apply(console, arguments))); },
            verbose() { !i.silent && i.verbose && i.debug && (i.performance ? r.performance.log(arguments) : (r.verbose = Function.prototype.bind.call(console.info, console, `${i.name}:`), r.verbose.apply(console, arguments))); },
            error() { i.silent || (r.error = Function.prototype.bind.call(console.error, console, `${i.name}:`), r.error.apply(console, arguments)); },
            performance: { log(e) {
              let o,
                n; i.performance && (n = (o = (new Date()).getTime()) - (C || o), C = o, y.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: p, 'Execution Time': n })), clearTimeout(r.performance.timer), r.performance.timer = setTimeout(r.performance.display, 500);
            },
              display() {
                let e = `${i.name}:`,
                  n = 0; C = !1, clearTimeout(r.performance.timer), O.each(y, (e, o) => { n += o['Execution Time']; }), e += ` ${n}ms`, x && (e += ` '${x}'`), (console.group !== w || console.table !== w) && y.length > 0 && (console.groupCollapsed(e), console.table ? console.table(y) : O.each(y, (e, o) => { console.log(`${o.Name}: ${o['Execution Time']}ms`); }), console.groupEnd()), y = [];
              } },
            invoke(t, e, o) {
              let i,
                s,
                n,
                c = g; return e = e || V, o = p || o, typeof t === 'string' && c !== w && (t = t.split(/[\. ]/), i = t.length - 1, O.each(t, (e, o) => { const n = e != i ? o + t[e + 1].charAt(0).toUpperCase() + t[e + 1].slice(1) : t; if (O.isPlainObject(c[n]) && e != i)c = c[n]; else { if (c[n] !== w) return s = c[n], !1; if (!O.isPlainObject(c[o]) || e == i) return c[o] !== w ? s = c[o] : r.error(a.method, t), !1; c = c[o]; } })), O.isFunction(s) ? n = s.apply(o, e) : s !== w && (n = s), O.isArray(P) ? P.push(n) : P !== w ? P = [P, n] : n !== w && (P = n), s;
            } }, R ? (g === w && r.initialize(), g.save.scroll(), g.save.calculations(), r.invoke(S)) : (g !== w && g.invoke('destroy'), r.initialize());
      }), P !== w ? P : this;
  }, O.fn.visibility.settings = { name: 'Visibility', namespace: 'visibility', debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: z, throttle: !1, type: !1, zIndex: '10', transition: 'fade in', duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onLoad() {}, onAllLoaded() {}, onFixed() {}, onUnfixed() {}, onUpdate: !1, onRefresh() {}, metadata: { src: 'src' }, className: { fixed: 'fixed', placeholder: 'placeholder', visible: 'visible' }, error: { method: 'The method you called is not defined.', visible: 'Element is hidden, you must call refresh after element becomes visible' } };
}(jQuery, window, document));
