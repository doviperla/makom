!(function (E, e, P, T) {
  void 0 !== (e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')()) && e.Math == Math || (typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')()); E.fn.progress = function (m) {
    let b,
      e = E(this),
      h = e.selector || '',
      x = (new Date()).getTime(),
      w = [],
      y = m,
      V = typeof y === 'string',
      C = [].slice.call(arguments, 1); return e.each(function () {
        let s,
          r = E.isPlainObject(m) ? E.extend(!0, {}, E.fn.progress.settings, m) : E.extend({}, E.fn.progress.settings),
          t = r.className,
          n = r.metadata,
          e = r.namespace,
          a = r.selector,
          l = r.error,
          o = `.${e}`,
          i = `module-${e}`,
          c = E(this),
          u = E(this).find(a.bar),
          d = E(this).find(a.progress),
          g = E(this).find(a.label),
          v = this,
          p = c.data(i),
          f = !1; s = { initialize() { s.debug('Initializing progress bar', r), s.set.duration(), s.set.transitionEvent(), s.read.metadata(), s.read.settings(), s.instantiate(); },
            instantiate() { s.verbose('Storing instance of progress', s), p = s, c.data(i, s); },
            destroy() { s.verbose('Destroying previous progress for', c), clearInterval(p.interval), s.remove.state(), c.removeData(i), p = T; },
            reset() { s.remove.nextValue(), s.update.progress(0); },
            complete() { (s.percent === T || s.percent < 100) && (s.remove.progressPoll(), s.set.percent(100)); },
            read: { metadata() { const e = { percent: c.data(n.percent), total: c.data(n.total), value: c.data(n.value) }; e.percent && (s.debug('Current percent value set from metadata', e.percent), s.set.percent(e.percent)), e.total && (s.debug('Total value set from metadata', e.total), s.set.total(e.total)), e.value && (s.debug('Current value set from metadata', e.value), s.set.value(e.value), s.set.progress(e.value)); }, settings() { !1 !== r.total && (s.debug('Current total set in settings', r.total), s.set.total(r.total)), !1 !== r.value && (s.debug('Current value set in settings', r.value), s.set.value(r.value), s.set.progress(s.value)), !1 !== r.percent && (s.debug('Current percent set in settings', r.percent), s.set.percent(r.percent)); } },
            bind: { transitionEnd(t) { const e = s.get.transitionEnd(); u.one(e + o, function (e) { clearTimeout(s.failSafeTimer), t.call(this, e); }), s.failSafeTimer = setTimeout(() => { u.triggerHandler(e); }, r.duration + r.failSafeDelay), s.verbose('Adding fail safe timer', s.timer); } },
            increment(e) {
              let t,
                n; s.has.total() ? n = (t = s.get.value()) + (e = e || 1) : (n = (t = s.get.percent()) + (e = e || s.get.randomValue()), 100, s.debug('Incrementing percentage by', t, n)), n = s.get.normalizedValue(n), s.set.progress(n);
            },
            decrement(e) {
              let t,
                n; s.get.total() ? (n = (t = s.get.value()) - (e = e || 1), s.debug('Decrementing value by', e, t)) : (n = (t = s.get.percent()) - (e = e || s.get.randomValue()), s.debug('Decrementing percentage by', e, t)), n = s.get.normalizedValue(n), s.set.progress(n);
            },
            has: { progressPoll() { return s.progressPoll; }, total() { return !1 !== s.get.total(); } },
            get: { text(e) {
              let t = s.value || 0,
                n = s.total || 0,
                r = f ? s.get.displayPercent() : s.percent || 0,
                a = s.total > 0 ? n - t : 100 - r; return e = (e = e || '').replace('{value}', t).replace('{total}', n).replace('{left}', a).replace('{percent}', r), s.verbose('Adding variables to progress bar text', e), e;
            },
              normalizedValue(e) { if (e < 0) return s.debug('Value cannot decrement below 0'), 0; if (s.has.total()) { if (e > s.total) return s.debug('Value cannot increment above total', s.total), s.total; } else if (e > 100) return s.debug('Value cannot increment above 100 percent'), 100; return e; },
              updateInterval() { return r.updateInterval == 'auto' ? r.duration : r.updateInterval; },
              randomValue() { return s.debug('Generating random increment percentage'), Math.floor(Math.random() * r.random.max + r.random.min); },
              numericValue(e) { return typeof e === 'string' ? e.replace(/[^\d.]/g, '') !== '' && +e.replace(/[^\d.]/g, '') : e; },
              transitionEnd() {
                let e,
                  t = P.createElement('element'),
                  n = { transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd' }; for (e in n) if (t.style[e] !== T) return n[e];
              },
              displayPercent() {
                let e = u.width(),
                  t = c.width(),
                  n = parseInt(u.css('min-width'), 10) < e ? e / t * 100 : s.percent; return r.precision > 0 ? Math.round(n * (10 * r.precision)) / (10 * r.precision) : Math.round(n);
              },
              percent() { return s.percent || 0; },
              value() { return s.nextValue || s.value || 0; },
              total() { return s.total || !1; } },
            create: { progressPoll() { s.progressPoll = setTimeout(() => { s.update.toNextValue(), s.remove.progressPoll(); }, s.get.updateInterval()); } },
            is: { complete() { return s.is.success() || s.is.warning() || s.is.error(); }, success() { return c.hasClass(t.success); }, warning() { return c.hasClass(t.warning); }, error() { return c.hasClass(t.error); }, active() { return c.hasClass(t.active); }, visible() { return c.is(':visible'); } },
            remove: { progressPoll() { s.verbose('Removing progress poll timer'), s.progressPoll && (clearTimeout(s.progressPoll), delete s.progressPoll); }, nextValue() { s.verbose('Removing progress value stored for next update'), delete s.nextValue; }, state() { s.verbose('Removing stored state'), delete s.total, delete s.percent, delete s.value; }, active() { s.verbose('Removing active state'), c.removeClass(t.active); }, success() { s.verbose('Removing success state'), c.removeClass(t.success); }, warning() { s.verbose('Removing warning state'), c.removeClass(t.warning); }, error() { s.verbose('Removing error state'), c.removeClass(t.error); } },
            set: { barWidth(e) { e > 100 ? s.error(l.tooHigh, e) : e < 0 ? s.error(l.tooLow, e) : (u.css('width', `${e}%`), c.attr('data-percent', parseInt(e, 10))); }, duration(e) { e = typeof (e = e || r.duration) === 'number' ? `${e}ms` : e, s.verbose('Setting progress bar transition duration', e), u.css({ 'transition-duration': e }); }, percent(e) { e = typeof e === 'string' ? +e.replace('%', '') : e, e = r.precision > 0 ? Math.round(e * (10 * r.precision)) / (10 * r.precision) : Math.round(e), s.percent = e, s.has.total() || (s.value = r.precision > 0 ? Math.round(e / 100 * s.total * (10 * r.precision)) / (10 * r.precision) : Math.round(e / 100 * s.total * 10) / 10, r.limitValues && (s.value = s.value > 100 ? 100 : s.value < 0 ? 0 : s.value)), s.set.barWidth(e), s.set.labelInterval(), s.set.labels(), r.onChange.call(v, e, s.value, s.total); }, labelInterval() { clearInterval(s.interval), s.bind.transitionEnd(() => { s.verbose('Bar finished animating, removing continuous label updates'), clearInterval(s.interval), f = !1, s.set.labels(); }), f = !0, s.interval = setInterval(() => { E.contains(P.documentElement, v) || (clearInterval(s.interval), f = !1), s.set.labels(); }, r.framerate); }, labels() { s.verbose('Setting both bar progress and outer label text'), s.set.barLabel(), s.set.state(); }, label(e) { (e = e || '') && (e = s.get.text(e), s.verbose('Setting label to text', e), g.text(e)); }, state(e) { (e = e !== T ? e : s.percent) === 100 ? r.autoSuccess && !(s.is.warning() || s.is.error() || s.is.success()) ? (s.set.success(), s.debug('Automatically triggering success at 100%')) : (s.verbose('Reached 100% removing active state'), s.remove.active(), s.remove.progressPoll()) : e > 0 ? (s.verbose('Adjusting active progress bar label', e), s.set.active()) : (s.remove.active(), s.set.label(r.text.active)); }, barLabel(e) { e !== T ? d.text(s.get.text(e)) : r.label == 'ratio' && s.total ? (s.verbose('Adding ratio to bar label'), d.text(s.get.text(r.text.ratio))) : r.label == 'percent' && (s.verbose('Adding percentage to bar label'), d.text(s.get.text(r.text.percent))); }, active(e) { e = e || r.text.active, s.debug('Setting active state'), r.showActivity && !s.is.active() && c.addClass(t.active), s.remove.warning(), s.remove.error(), s.remove.success(), (e = r.onLabelUpdate('active', e, s.value, s.total)) && s.set.label(e), s.bind.transitionEnd(() => { r.onActive.call(v, s.value, s.total); }); }, success(e) { e = e || r.text.success || r.text.active, s.debug('Setting success state'), c.addClass(t.success), s.remove.active(), s.remove.warning(), s.remove.error(), s.complete(), e = r.text.success ? r.onLabelUpdate('success', e, s.value, s.total) : r.onLabelUpdate('active', e, s.value, s.total), s.set.label(e), s.bind.transitionEnd(() => { r.onSuccess.call(v, s.total); }); }, warning(e) { e = e || r.text.warning, s.debug('Setting warning state'), c.addClass(t.warning), s.remove.active(), s.remove.success(), s.remove.error(), s.complete(), (e = r.onLabelUpdate('warning', e, s.value, s.total)) && s.set.label(e), s.bind.transitionEnd(() => { r.onWarning.call(v, s.value, s.total); }); }, error(e) { e = e || r.text.error, s.debug('Setting error state'), c.addClass(t.error), s.remove.active(), s.remove.success(), s.remove.warning(), s.complete(), (e = r.onLabelUpdate('error', e, s.value, s.total)) && s.set.label(e), s.bind.transitionEnd(() => { r.onError.call(v, s.value, s.total); }); }, transitionEvent() { s.get.transitionEnd(); }, total(e) { s.total = e; }, value(e) { s.value = e; }, progress(e) { s.has.progressPoll() ? (s.debug('Updated within interval, setting next update to use new value', e), s.set.nextValue(e)) : (s.debug('First update in progress update interval, immediately updating', e), s.update.progress(e), s.create.progressPoll()); }, nextValue(e) { s.nextValue = e; } },
            update: { toNextValue() { const e = s.nextValue; e && (s.debug('Update interval complete using last updated value', e), s.update.progress(e), s.remove.nextValue()); }, progress(e) { let t; !1 === (e = s.get.numericValue(e)) && s.error(l.nonNumeric, e), e = s.get.normalizedValue(e), s.has.total() ? (s.set.value(e), t = e / s.total * 100, s.debug('Calculating percent complete from total', t)) : (t = e, s.debug('Setting value to exact percentage value', t)), s.set.percent(t); } },
            setting(e, t) { if (s.debug('Changing setting', e, t), E.isPlainObject(e))E.extend(!0, r, e); else { if (t === T) return r[e]; E.isPlainObject(r[e]) ? E.extend(!0, r[e], t) : r[e] = t; } },
            internal(e, t) { if (E.isPlainObject(e))E.extend(!0, s, e); else { if (t === T) return s[e]; s[e] = t; } },
            debug() { !r.silent && r.debug && (r.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${r.name}:`), s.debug.apply(console, arguments))); },
            verbose() { !r.silent && r.verbose && r.debug && (r.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${r.name}:`), s.verbose.apply(console, arguments))); },
            error() { r.silent || (s.error = Function.prototype.bind.call(console.error, console, `${r.name}:`), s.error.apply(console, arguments)); },
            performance: { log(e) {
              let t,
                n; r.performance && (n = (t = (new Date()).getTime()) - (x || t), x = t, w.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: v, 'Execution Time': n })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
            },
              display() {
                let e = `${r.name}:`,
                  n = 0; x = !1, clearTimeout(s.performance.timer), E.each(w, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, h && (e += ` '${h}'`), (console.group !== T || console.table !== T) && w.length > 0 && (console.groupCollapsed(e), console.table ? console.table(w) : E.each(w, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), w = [];
              } },
            invoke(r, e, t) {
              let a,
                o,
                n,
                i = p; return e = e || C, t = v || t, typeof r === 'string' && i !== T && (r = r.split(/[\. ]/), a = r.length - 1, E.each(r, (e, t) => { const n = e != a ? t + r[e + 1].charAt(0).toUpperCase() + r[e + 1].slice(1) : r; if (E.isPlainObject(i[n]) && e != a)i = i[n]; else { if (i[n] !== T) return o = i[n], !1; if (!E.isPlainObject(i[t]) || e == a) return i[t] !== T ? o = i[t] : s.error(l.method, r), !1; i = i[t]; } })), E.isFunction(o) ? n = o.apply(t, e) : o !== T && (n = o), E.isArray(b) ? b.push(n) : b !== T ? b = [b, n] : n !== T && (b = n), o;
            } }, V ? (p === T && s.initialize(), s.invoke(y)) : (p !== T && p.invoke('destroy'), s.initialize());
      }), b !== T ? b : this;
  }, E.fn.progress.settings = { name: 'Progress', namespace: 'progress', silent: !1, debug: !1, verbose: !1, performance: !0, random: { min: 2, max: 5 }, duration: 300, updateInterval: 'auto', autoSuccess: !0, showActivity: !0, limitValues: !0, label: 'percent', precision: 0, framerate: 1e3 / 30, percent: !1, total: !1, value: !1, failSafeDelay: 100, onLabelUpdate(e, t, n, r) { return t; }, onChange(e, t, n) {}, onSuccess(e) {}, onActive(e, t) {}, onError(e, t) {}, onWarning(e, t) {}, error: { method: 'The method you called is not defined.', nonNumeric: 'Progress value is non numeric', tooHigh: 'Value specified is above 100%', tooLow: 'Value specified is below 0%' }, regExp: { variable: /\{\$*[A-z0-9]+\}/g }, metadata: { percent: 'percent', total: 'total', value: 'value' }, selector: { bar: '> .bar', label: '> .label', progress: '.bar > .progress' }, text: { active: !1, error: !1, success: !1, warning: !1, percent: '{percent}%', ratio: '{value} of {total}' }, className: { active: 'active', error: 'error', success: 'success', warning: 'warning' } };
}(jQuery, window, document));
