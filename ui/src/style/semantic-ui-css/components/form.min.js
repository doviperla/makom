!(function (T, e, D, O) {
  e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), T.fn.form = function (x) {
    let k,
      E = T(this),
      w = E.selector || '',
      C = (new Date()).getTime(),
      V = [],
      R = x,
      F = arguments[1],
      S = typeof R === 'string',
      A = [].slice.call(arguments, 1); return E.each(function () {
        let n,
          s,
          t,
          e,
          d,
          u,
          c,
          f,
          p,
          r,
          l,
          i,
          a,
          m,
          g,
          h,
          o = T(this),
          v = this,
          b = [],
          y = !1; (h = { initialize() { h.get.settings(), S ? (g === O && h.instantiate(), h.invoke(R)) : (g !== O && g.invoke('destroy'), h.verbose('Initializing form validation', o, d), h.bindEvents(), h.set.defaults(), h.instantiate()); },
            instantiate() { h.verbose('Storing instance of module', h), g = h, o.data(a, h); },
            destroy() { h.verbose('Destroying previous module', g), h.removeEvents(), o.removeData(a); },
            refresh() { h.verbose('Refreshing selector cache'), n = o.find(f.field), s = o.find(f.group), t = o.find(f.message), o.find(f.prompt), e = o.find(f.submit), o.find(f.clear), o.find(f.reset); },
            submit() { h.verbose('Submitting form', o), o.submit(); },
            attachEvents(e, t) { t = t || 'submit', T(e).on(`click${m}`, (e) => { h[t](), e.preventDefault(); }); },
            bindEvents() {
              h.verbose('Attaching form events'), o.on(`submit${m}`, h.validate.form).on(`blur${m}`, f.field, h.event.field.blur).on(`click${m}`, f.submit, h.submit).on(`click${m}`, f.reset, h.reset).on(`click${m}`, f.clear, h.clear), d.keyboardShortcuts && o.on(`keydown${m}`, f.field, h.event.field.keydown), n.each(function () {
                let e = T(this),
                  t = e.prop('type'),
                  n = h.get.changeEvent(t, e); T(this).on(n + m, h.event.field.change);
              });
            },
            clear() {
              n.each(function () {
                let e = T(this),
                  t = e.parent(),
                  n = e.closest(s),
                  r = n.find(f.prompt),
                  i = e.data(c.defaultValue) || '',
                  a = t.is(f.uiCheckbox),
                  o = t.is(f.uiDropdown); n.hasClass(p.error) && (h.verbose('Resetting error on field', n), n.removeClass(p.error), r.remove()), o ? (h.verbose('Resetting dropdown value', t, i), t.dropdown('clear')) : a ? e.prop('checked', !1) : (h.verbose('Resetting field value', e, i), e.val(''));
              });
            },
            reset() {
              n.each(function () {
                let e = T(this),
                  t = e.parent(),
                  n = e.closest(s),
                  r = n.find(f.prompt),
                  i = e.data(c.defaultValue),
                  a = t.is(f.uiCheckbox),
                  o = t.is(f.uiDropdown),
                  l = n.hasClass(p.error); i !== O && (l && (h.verbose('Resetting error on field', n), n.removeClass(p.error), r.remove()), o ? (h.verbose('Resetting dropdown value', t, i), t.dropdown('restore defaults')) : a ? (h.verbose('Resetting checkbox value', t, i), e.prop('checked', i)) : (h.verbose('Resetting field value', e, i), e.val(i)));
              });
            },
            determine: { isValid() { let n = !0; return T.each(u, (e, t) => { h.validate.field(t, e, !0) || (n = !1); }), n; } },
            is: { bracketedRule(e) { return e.type && e.type.match(d.regExp.bracket); }, shorthandFields(e) { const t = e[Object.keys(e)[0]]; return h.is.shorthandRules(t); }, shorthandRules(e) { return typeof e === 'string' || T.isArray(e); }, empty(e) { return !e || e.length === 0 || (e.is('input[type="checkbox"]') ? !e.is(':checked') : h.is.blank(e)); }, blank(e) { return T.trim(e.val()) === ''; }, valid(e) { let n = !0; return e ? (h.verbose('Checking if field is valid', e), h.validate.field(u[e], e, !1)) : (h.verbose('Checking if form is valid'), T.each(u, (e, t) => { h.is.valid(e) || (n = !1); }), n); } },
            removeEvents() { o.off(m), n.off(m), e.off(m), n.off(m); },
            event: { field: { keydown(e) {
              let t = T(this),
                n = e.which,
                r = t.is(f.input),
                i = t.is(f.checkbox),
                a = t.closest(f.uiDropdown).length > 0,
                o = 13; n == 27 && (h.verbose('Escape key pressed blurring field'), t.blur()), e.ctrlKey || n != o || !r || a || i || (y || (t.one(`keyup${m}`, h.event.field.keyup), h.submit(), h.debug('Enter pressed on input submitting form')), y = !0);
            },
              keyup() { y = !1; },
              blur(e) {
                let t = T(this),
                  n = t.closest(s),
                  r = h.get.validation(t); n.hasClass(p.error) ? (h.debug('Revalidating field', t, r), r && h.validate.field(r)) : d.on == 'blur' && r && h.validate.field(r);
              },
              change(e) {
                let t = T(this),
                  n = t.closest(s),
                  r = h.get.validation(t); r && (d.on == 'change' || n.hasClass(p.error) && d.revalidate) && (clearTimeout(h.timer), h.timer = setTimeout(() => { h.debug('Revalidating field', t, h.get.validation(t)), h.validate.field(r); }, d.delay));
              } } },
            get: { ancillaryValue(e) { return !(!e.type || !e.value && !h.is.bracketedRule(e)) && (e.value !== O ? e.value : `${e.type.match(d.regExp.bracket)[1]}`); },
              ruleName(e) { return h.is.bracketedRule(e) ? e.type.replace(e.type.match(d.regExp.bracket)[0], '') : e.type; },
              changeEvent(e, t) { return e == 'checkbox' || e == 'radio' || e == 'hidden' || t.is('select') ? 'change' : h.get.inputEvent(); },
              inputEvent() { return D.createElement('input').oninput !== O ? 'input' : D.createElement('input').onpropertychange !== O ? 'propertychange' : 'keyup'; },
              fieldsFromShorthand(e) { const r = {}; return T.each(e, (n, e) => { typeof e === 'string' && (e = [e]), r[n] = { rules: [] }, T.each(e, (e, t) => { r[n].rules.push({ type: t }); }); }), r; },
              prompt(e, t) {
                let n,
                  r,
                  i = h.get.ruleName(e),
                  a = h.get.ancillaryValue(e),
                  o = h.get.field(t.identifier),
                  l = o.val(),
                  s = T.isFunction(e.prompt) ? e.prompt(l) : e.prompt || d.prompt[i] || d.text.unspecifiedRule,
                  u = s.search('{value}') !== -1,
                  c = s.search('{name}') !== -1; return u && (s = s.replace('{value}', o.val())), c && (r = (n = o.closest(f.group).find('label').eq(0)).length == 1 ? n.text() : o.prop('placeholder') || d.text.unspecifiedField, s = s.replace('{name}', r)), s = (s = s.replace('{identifier}', t.identifier)).replace('{ruleValue}', a), e.prompt || h.verbose('Using default validation prompt for type', s, i), s;
              },
              settings() { if (T.isPlainObject(x)) { const e = Object.keys(x); e.length > 0 && (x[e[0]].identifier !== O && x[e[0]].rules !== O) ? (d = T.extend(!0, {}, T.fn.form.settings, F), u = T.extend({}, T.fn.form.settings.defaults, x), h.error(d.error.oldSyntax, v), h.verbose('Extending settings from legacy parameters', u, d)) : (x.fields && h.is.shorthandFields(x.fields) && (x.fields = h.get.fieldsFromShorthand(x.fields)), d = T.extend(!0, {}, T.fn.form.settings, x), u = T.extend({}, T.fn.form.settings.defaults, d.fields), h.verbose('Extending settings', u, d)); } else d = T.fn.form.settings, u = T.fn.form.settings.defaults, h.verbose('Using default form validation', u, d); i = d.namespace, c = d.metadata, f = d.selector, p = d.className, r = d.regExp, l = d.error, a = `module-${i}`, m = `.${i}`, g = o.data(a), h.refresh(); },
              field(e) { return h.verbose('Finding field with identifier', e), e = h.escape.string(e), n.filter(`#${e}`).length > 0 ? n.filter(`#${e}`) : n.filter(`[name="${e}"]`).length > 0 ? n.filter(`[name="${e}"]`) : n.filter(`[name="${e}[]"]`).length > 0 ? n.filter(`[name="${e}[]"]`) : n.filter(`[data-${c.validate}="${e}"]`).length > 0 ? n.filter(`[data-${c.validate}="${e}"]`) : T('<input/>'); },
              fields(e) { let n = T(); return T.each(e, (e, t) => { n = n.add(h.get.field(t)); }), n; },
              validation(n) {
                let r,
                  i; return !!u && (T.each(u, (e, t) => { i = t.identifier || e, h.get.field(i)[0] == n[0] && (t.identifier = i, r = t); }), r || !1);
              },
              value(e) { const t = []; return t.push(e), h.get.values.call(v, t)[e]; },
              values(e) {
                let t = T.isArray(e) ? h.get.fields(e) : n,
                  u = {}; return t.each((e, t) => {
                    let n = T(t),
                      r = (n.prop('type'), n.prop('name')),
                      i = n.val(),
                      a = n.is(f.checkbox),
                      o = n.is(f.radio),
                      l = r.indexOf('[]') !== -1,
                      s = !!a && n.is(':checked'); r && (l ? (r = r.replace('[]', ''), u[r] || (u[r] = []), a ? s ? u[r].push(i || !0) : u[r].push(!1) : u[r].push(i)) : o ? u[r] !== O && u[r] != 0 || (u[r] = !!s && (i || !0)) : u[r] = a ? !!s && (i || !0) : i);
                  }), u;
              } },
            has: { field(e) { return h.verbose('Checking for existence of a field with identifier', e), typeof (e = h.escape.string(e)) !== 'string' && h.error(l.identifier, e), n.filter(`#${e}`).length > 0 || (n.filter(`[name="${e}"]`).length > 0 || n.filter(`[data-${c.validate}="${e}"]`).length > 0); } },
            escape: { string(e) { return (e = String(e)).replace(r.escape, '\\$&'); } },
            add: { rule(e, t) { h.add.field(e, t); },
              field(n, e) { const r = {}; h.is.shorthandRules(e) ? (e = T.isArray(e) ? e : [e], r[n] = { rules: [] }, T.each(e, (e, t) => { r[n].rules.push({ type: t }); })) : r[n] = e, u = T.extend({}, u, r), h.debug('Adding rules', r, u); },
              fields(e) { let t; t = e && h.is.shorthandFields(e) ? h.get.fieldsFromShorthand(e) : e, u = T.extend({}, u, t); },
              prompt(e, t) {
                let n = h.get.field(e).closest(s),
                  r = n.children(f.prompt),
                  i = r.length !== 0; t = typeof t === 'string' ? [t] : t, h.verbose('Adding field error state', e), n.addClass(p.error), d.inline && (i || (r = d.templates.prompt(t)).appendTo(n), r.html(t[0]), i ? h.verbose('Inline errors are disabled, no inline error added', e) : d.transition && T.fn.transition !== O && o.transition('is supported') ? (h.verbose('Displaying error with css transition', d.transition), r.transition(`${d.transition} in`, d.duration)) : (h.verbose('Displaying error with fallback javascript animation'), r.fadeIn(d.duration)));
              },
              errors(e) { h.debug('Adding form error messages', e), h.set.error(), t.html(d.templates.error(e)); } },
            remove: { rule(n, e) { const r = T.isArray(e) ? e : [e]; if (e == O) return h.debug('Removed all rules'), void (u[n].rules = []); u[n] != O && T.isArray(u[n].rules) && T.each(u[n].rules, (e, t) => { r.indexOf(t.type) !== -1 && (h.debug('Removed rule', t.type), u[n].rules.splice(e, 1)); }); },
              field(e) { const t = T.isArray(e) ? e : [e]; T.each(t, (e, t) => { h.remove.rule(t); }); },
              rules(e, n) { T.isArray(e) ? T.each(fields, (e, t) => { h.remove.rule(t, n); }) : h.remove.rule(e, n); },
              fields(e) { h.remove.field(e); },
              prompt(e) {
                let t = h.get.field(e).closest(s),
                  n = t.children(f.prompt); t.removeClass(p.error), d.inline && n.is(':visible') && (h.verbose('Removing prompt for field', e), d.transition && T.fn.transition !== O && o.transition('is supported') ? n.transition(`${d.transition} out`, d.duration, () => { n.remove(); }) : n.fadeOut(d.duration, () => { n.remove(); }));
              } },
            set: { success() { o.removeClass(p.error).addClass(p.success); },
              defaults() {
                n.each(function () {
                  let e = T(this),
                    t = e.filter(f.checkbox).length > 0 ? e.is(':checked') : e.val(); e.data(c.defaultValue, t);
                });
              },
              error() { o.removeClass(p.success).addClass(p.error); },
              value(e, t) { const n = {}; return n[e] = t, h.set.values.call(v, n); },
              values(e) {
                T.isEmptyObject(e) || T.each(e, (e, t) => {
                  let n,
                    r = h.get.field(e),
                    i = r.parent(),
                    a = T.isArray(t),
                    o = i.is(f.uiCheckbox),
                    l = i.is(f.uiDropdown),
                    s = r.is(f.radio) && o; r.length > 0 && (a && o ? (h.verbose('Selecting multiple', t, r), i.checkbox('uncheck'), T.each(t, (e, t) => { n = r.filter(`[value="${t}"]`), i = n.parent(), n.length > 0 && i.checkbox('check'); })) : s ? (h.verbose('Selecting radio value', t, r), r.filter(`[value="${t}"]`).parent(f.uiCheckbox).checkbox('check')) : o ? (h.verbose('Setting checkbox value', t, i), !0 === t ? i.checkbox('check') : i.checkbox('uncheck')) : l ? (h.verbose('Setting dropdown value', t, i), i.dropdown('set selected', t)) : (h.verbose('Setting field value', t, r), r.val(t)));
                });
              } },
            validate: { form(e, t) { const n = h.get.values(); if (y) return !1; if (b = [], h.determine.isValid()) { if (h.debug('Form has no validation errors, submitting'), h.set.success(), !0 !== t) return d.onSuccess.call(v, e, n); } else if (h.debug('Form has errors'), h.set.error(), d.inline || h.add.errors(b), o.data('moduleApi') !== O && e.stopImmediatePropagation(), !0 !== t) return d.onFailure.call(v, b, n); },
              field(n, e, t) {
                t = t === O || t, typeof n === 'string' && (h.verbose('Validating field', n), n = u[e = n]); let r = n.identifier || e,
                  i = h.get.field(r),
                  a = !!n.depends && h.get.field(n.depends),
                  o = !0,
                  l = []; return n.identifier || (h.debug('Using field name as identifier', r), n.identifier = r), i.prop('disabled') ? (h.debug('Field is disabled. Skipping', r), o = !0) : n.optional && h.is.blank(i) ? (h.debug('Field is optional and blank. Skipping', r), o = !0) : n.depends && h.is.empty(a) ? (h.debug('Field depends on another value that is not present or empty. Skipping', a), o = !0) : n.rules !== O && T.each(n.rules, (e, t) => { h.has.field(r) && !h.validate.rule(n, t) && (h.debug('Field is invalid', r, t.type), l.push(h.get.prompt(t, n)), o = !1); }), o ? (t && (h.remove.prompt(r, l), d.onValid.call(i)), !0) : (t && (b = b.concat(l), h.add.prompt(r, l), d.onInvalid.call(i, l)), !1);
              },
              rule(e, t) {
                let n = h.get.field(e.identifier),
                  r = (t.type, n.val()),
                  i = h.get.ancillaryValue(t),
                  a = h.get.ruleName(t),
                  o = d.rules[a]; if (T.isFunction(o)) return r = r === O || r === '' || r === null ? '' : T.trim(`${r}`), o.call(n, r, i); h.error(l.noRule, a);
              } },
            setting(e, t) { if (T.isPlainObject(e))T.extend(!0, d, e); else { if (t === O) return d[e]; d[e] = t; } },
            internal(e, t) { if (T.isPlainObject(e))T.extend(!0, h, e); else { if (t === O) return h[e]; h[e] = t; } },
            debug() { !d.silent && d.debug && (d.performance ? h.performance.log(arguments) : (h.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), h.debug.apply(console, arguments))); },
            verbose() { !d.silent && d.verbose && d.debug && (d.performance ? h.performance.log(arguments) : (h.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), h.verbose.apply(console, arguments))); },
            error() { d.silent || (h.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), h.error.apply(console, arguments)); },
            performance: { log(e) {
              let t,
                n; d.performance && (n = (t = (new Date()).getTime()) - (C || t), C = t, V.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: v, 'Execution Time': n })), clearTimeout(h.performance.timer), h.performance.timer = setTimeout(h.performance.display, 500);
            },
              display() {
                let e = `${d.name}:`,
                  n = 0; C = !1, clearTimeout(h.performance.timer), T.each(V, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, w && (e += ` '${w}'`), E.length > 1 && (e += ` (${E.length})`), (console.group !== O || console.table !== O) && V.length > 0 && (console.groupCollapsed(e), console.table ? console.table(V) : T.each(V, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), V = [];
              } },
            invoke(r, e, t) {
              let i,
                a,
                n,
                o = g; return e = e || A, t = v || t, typeof r === 'string' && o !== O && (r = r.split(/[\. ]/), i = r.length - 1, T.each(r, (e, t) => { const n = e != i ? t + r[e + 1].charAt(0).toUpperCase() + r[e + 1].slice(1) : r; if (T.isPlainObject(o[n]) && e != i)o = o[n]; else { if (o[n] !== O) return a = o[n], !1; if (!T.isPlainObject(o[t]) || e == i) return o[t] !== O && (a = o[t]), !1; o = o[t]; } })), T.isFunction(a) ? n = a.apply(t, e) : a !== O && (n = a), T.isArray(k) ? k.push(n) : k !== O ? k = [k, n] : n !== O && (k = n), a;
            } }).initialize();
      }), k !== O ? k : this;
  }, T.fn.form.settings = { name: 'Form',
    namespace: 'form',
    debug: !1,
    verbose: !1,
    performance: !0,
    fields: !1,
    keyboardShortcuts: !0,
    on: 'submit',
    inline: !1,
    delay: 200,
    revalidate: !0,
    transition: 'scale',
    duration: 200,
    onValid() {},
    onInvalid() {},
    onSuccess() { return !0; },
    onFailure() { return !1; },
    metadata: { defaultValue: 'default', validate: 'validate' },
    regExp: { htmlID: /^[a-zA-Z][\w:.-]*$/g, bracket: /\[(.*)\]/i, decimal: /^\d+\.?\d*$/, email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, flags: /^\/(.*)\/(.*)?/, integer: /^\-?\d+$/, number: /^\-?\d*(\.\d+)?$/, url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i },
    text: { unspecifiedRule: 'Please enter a valid value', unspecifiedField: 'This field' },
    prompt: { empty: '{name} must have a value', checked: '{name} must be checked', email: '{name} must be a valid e-mail', url: '{name} must be a valid url', regExp: '{name} is not formatted correctly', integer: '{name} must be an integer', decimal: '{name} must be a decimal number', number: '{name} must be set to a number', is: '{name} must be "{ruleValue}"', isExactly: '{name} must be exactly "{ruleValue}"', not: '{name} cannot be set to "{ruleValue}"', notExactly: '{name} cannot be set to exactly "{ruleValue}"', contain: '{name} must contain "{ruleValue}"', containExactly: '{name} must contain exactly "{ruleValue}"', doesntContain: '{name} cannot contain  "{ruleValue}"', doesntContainExactly: '{name} cannot contain exactly "{ruleValue}"', minLength: '{name} must be at least {ruleValue} characters', length: '{name} must be at least {ruleValue} characters', exactLength: '{name} must be exactly {ruleValue} characters', maxLength: '{name} cannot be longer than {ruleValue} characters', match: '{name} must match {ruleValue} field', different: '{name} must have a different value than {ruleValue} field', creditCard: '{name} must be a valid credit card number', minCount: '{name} must have at least {ruleValue} choices', exactCount: '{name} must have exactly {ruleValue} choices', maxCount: '{name} must have {ruleValue} or less choices' },
    selector: { checkbox: 'input[type="checkbox"], input[type="radio"]', clear: '.clear', field: 'input, textarea, select', group: '.field', input: 'input', message: '.error.message', prompt: '.prompt.label', radio: 'input[type="radio"]', reset: '.reset:not([type="reset"])', submit: '.submit:not([type="submit"])', uiCheckbox: '.ui.checkbox', uiDropdown: '.ui.dropdown' },
    className: { error: 'error', label: 'ui prompt label', pressed: 'down', success: 'success' },
    error: { identifier: 'You must specify a string identifier for each field', method: 'The method you called is not defined.', noRule: 'There is no rule matching the one you specified', oldSyntax: 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.' },
    templates: { error(e) { let n = '<ul class="list">'; return T.each(e, (e, t) => { n += `<li>${t}</li>`; }), T(n += '</ul>'); }, prompt(e) { return T('<div/>').addClass('ui basic red pointing prompt label').html(e[0]); } },
    rules: { empty(e) { return !(e === O || e === '' || T.isArray(e) && e.length === 0); },
      checked() { return T(this).filter(':checked').length > 0; },
      email(e) { return T.fn.form.settings.regExp.email.test(e); },
      url(e) { return T.fn.form.settings.regExp.url.test(e); },
      regExp(e, t) {
        if (t instanceof RegExp) return e.match(t); let n,
          r = t.match(T.fn.form.settings.regExp.flags); return r && (t = r.length >= 2 ? r[1] : t, n = r.length >= 3 ? r[2] : ''), e.match(new RegExp(t, n));
      },
      integer(e, t) {
        let n,
          r,
          i,
          a = T.fn.form.settings.regExp.integer; return t && ['', '..'].indexOf(t) === -1 && (t.indexOf('..') == -1 ? a.test(t) && (n = r = t - 0) : (i = t.split('..', 2), a.test(i[0]) && (n = i[0] - 0), a.test(i[1]) && (r = i[1] - 0))), a.test(e) && (n === O || n <= e) && (r === O || e <= r);
      },
      decimal(e) { return T.fn.form.settings.regExp.decimal.test(e); },
      number(e) { return T.fn.form.settings.regExp.number.test(e); },
      is(e, t) { return t = typeof t === 'string' ? t.toLowerCase() : t, (e = typeof e === 'string' ? e.toLowerCase() : e) == t; },
      isExactly(e, t) { return e == t; },
      not(e, t) { return (e = typeof e === 'string' ? e.toLowerCase() : e) != (t = typeof t === 'string' ? t.toLowerCase() : t); },
      notExactly(e, t) { return e != t; },
      contains(e, t) { return t = t.replace(T.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t, 'i')) !== -1; },
      containsExactly(e, t) { return t = t.replace(T.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t)) !== -1; },
      doesntContain(e, t) { return t = t.replace(T.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t, 'i')) === -1; },
      doesntContainExactly(e, t) { return t = t.replace(T.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t)) === -1; },
      minLength(e, t) { return e !== O && e.length >= t; },
      length(e, t) { return e !== O && e.length >= t; },
      exactLength(e, t) { return e !== O && e.length == t; },
      maxLength(e, t) { return e !== O && e.length <= t; },
      match(e, t) { let n; T(this); return T(`[data-validate="${t}"]`).length > 0 ? n = T(`[data-validate="${t}"]`).val() : T(`#${t}`).length > 0 ? n = T(`#${t}`).val() : T(`[name="${t}"]`).length > 0 ? n = T(`[name="${t}"]`).val() : T(`[name="${t}[]"]`).length > 0 && (n = T(`[name="${t}[]"]`)), n !== O && e.toString() == n.toString(); },
      different(e, t) { let n; T(this); return T(`[data-validate="${t}"]`).length > 0 ? n = T(`[data-validate="${t}"]`).val() : T(`#${t}`).length > 0 ? n = T(`#${t}`).val() : T(`[name="${t}"]`).length > 0 ? n = T(`[name="${t}"]`).val() : T(`[name="${t}[]"]`).length > 0 && (n = T(`[name="${t}[]"]`)), n !== O && e.toString() !== n.toString(); },
      creditCard(n, e) {
        let t,
          r,
          i = { visa: { pattern: /^4/, length: [16] }, amex: { pattern: /^3[47]/, length: [15] }, mastercard: { pattern: /^5[1-5]/, length: [16] }, discover: { pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/, length: [16] }, unionPay: { pattern: /^(62|88)/, length: [16, 17, 18, 19] }, jcb: { pattern: /^35(2[89]|[3-8][0-9])/, length: [16] }, maestro: { pattern: /^(5018|5020|5038|6304|6759|676[1-3])/, length: [12, 13, 14, 15, 16, 17, 18, 19] }, dinersClub: { pattern: /^(30[0-5]|^36)/, length: [14] }, laser: { pattern: /^(6304|670[69]|6771)/, length: [16, 17, 18, 19] }, visaElectron: { pattern: /^(4026|417500|4508|4844|491(3|7))/, length: [16] } },
          a = {},
          o = !1,
          l = typeof e === 'string' && e.split(','); if (typeof n === 'string' && n.length !== 0) { if (n = n.replace(/[\-]/g, ''), l && (T.each(l, (e, t) => { (r = i[t]) && (a = { length: T.inArray(n.length, r.length) !== -1, pattern: n.search(r.pattern) !== -1 }).length && a.pattern && (o = !0); }), !o)) return !1; if ((t = { number: T.inArray(n.length, i.unionPay.length) !== -1, pattern: n.search(i.unionPay.pattern) !== -1 }).number && t.pattern) return !0; for (var s = n.length, u = 0, c = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], d = 0; s--;)d += c[u][parseInt(n.charAt(s), 10)], u ^= 1; return d % 10 == 0 && d > 0; }
      },
      minCount(e, t) { return t == 0 || (t == 1 ? e !== '' : e.split(',').length >= t); },
      exactCount(e, t) { return t == 0 ? e === '' : t == 1 ? e !== '' && e.search(',') === -1 : e.split(',').length == t; },
      maxCount(e, t) { return t != 0 && (t == 1 ? e.search(',') === -1 : e.split(',').length <= t); } } };
}(jQuery, window, document));
