!(function (e, t, n, a) {
  t = void 0 !== t && t.Math == Math ? t : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), e.fn.state = function (t) {
    let i,
      o = e(this),
      s = o.selector || '',
      c = (n.documentElement, (new Date()).getTime()),
      r = [],
      l = arguments[0],
      u = typeof l === 'string',
      d = [].slice.call(arguments, 1); return o.each(function () {
        let n,
          f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.state.settings, t) : e.extend({}, e.fn.state.settings),
          v = f.error,
          g = f.metadata,
          b = f.className,
          x = f.namespace,
          h = f.states,
          m = f.text,
          p = `.${x}`,
          T = `${x}-module`,
          y = e(this),
          w = this,
          C = y.data(T); n = { initialize() { n.verbose('Initializing module'), f.automatic && n.add.defaults(), f.context && s !== '' ? e(f.context).on(s, `mouseenter${p}`, n.change.text).on(s, `mouseleave${p}`, n.reset.text).on(s, `click${p}`, n.toggle.state) : y.on(`mouseenter${p}`, n.change.text).on(`mouseleave${p}`, n.reset.text).on(`click${p}`, n.toggle.state), n.instantiate(); },
            instantiate() { n.verbose('Storing instance of module', n), C = n, y.data(T, n); },
            destroy() { n.verbose('Destroying previous module', C), y.off(p).removeData(T); },
            refresh() { n.verbose('Refreshing selector cache'), y = e(w); },
            add: { defaults() { const i = t && e.isPlainObject(t.states) ? t.states : {}; e.each(f.defaults, (t, o) => { n.is[t] !== a && n.is[t]() && (n.verbose('Adding default states', t, w), e.extend(f.states, o, i)); }); } },
            is: { active() { return y.hasClass(b.active); }, loading() { return y.hasClass(b.loading); }, inactive() { return !y.hasClass(b.active); }, state(e) { return b[e] !== a && y.hasClass(b[e]); }, enabled() { return !y.is(f.filter.active); }, disabled() { return y.is(f.filter.active); }, textEnabled() { return !y.is(f.filter.text); }, button() { return y.is('.button:not(a, .submit)'); }, input() { return y.is('input'); }, progress() { return y.is('.ui.progress'); } },
            allow(e) { n.debug('Now allowing state', e), h[e] = !0; },
            disallow(e) { n.debug('No longer allowing', e), h[e] = !1; },
            allows(e) { return h[e] || !1; },
            enable() { y.removeClass(b.disabled); },
            disable() { y.addClass(b.disabled); },
            setState(e) { n.allows(e) && y.addClass(b[e]); },
            removeState(e) { n.allows(e) && y.removeClass(b[e]); },
            toggle: { state() { let t; if (n.allows('active') && n.is.enabled()) { if (n.refresh(), e.fn.api !== a) if (t = y.api('get request'), y.api('was cancelled'))n.debug('API Request cancelled by beforesend'), f.activateTest = function () { return !1; }, f.deactivateTest = function () { return !1; }; else if (t) return void n.listenTo(t); n.change.state(); } } },
            listenTo(t) { n.debug('API request detected, waiting for state signal', t), t && (m.loading && n.update.text(m.loading), e.when(t).then(() => { t.state() == 'resolved' ? (n.debug('API request succeeded'), f.activateTest = function () { return !0; }, f.deactivateTest = function () { return !0; }) : (n.debug('API request failed'), f.activateTest = function () { return !1; }, f.deactivateTest = function () { return !1; }), n.change.state(); })); },
            change: { state() { n.debug('Determining state change direction'), n.is.inactive() ? n.activate() : n.deactivate(), f.sync && n.sync(), f.onChange.call(w); }, text() { n.is.textEnabled() && (n.is.disabled() ? (n.verbose('Changing text to disabled text', m.hover), n.update.text(m.disabled)) : n.is.active() ? m.hover ? (n.verbose('Changing text to hover text', m.hover), n.update.text(m.hover)) : m.deactivate && (n.verbose('Changing text to deactivating text', m.deactivate), n.update.text(m.deactivate)) : m.hover ? (n.verbose('Changing text to hover text', m.hover), n.update.text(m.hover)) : m.activate && (n.verbose('Changing text to activating text', m.activate), n.update.text(m.activate))); } },
            activate() { f.activateTest.call(w) && (n.debug('Setting state to active'), y.addClass(b.active), n.update.text(m.active), f.onActivate.call(w)); },
            deactivate() { f.deactivateTest.call(w) && (n.debug('Setting state to inactive'), y.removeClass(b.active), n.update.text(m.inactive), f.onDeactivate.call(w)); },
            sync() { n.verbose('Syncing other buttons to current state'), n.is.active() ? o.not(y).state('activate') : o.not(y).state('deactivate'); },
            get: { text() { return f.selector.text ? y.find(f.selector.text).text() : y.html(); }, textFor(e) { return m[e] || !1; } },
            flash: { text(e, t, a) { const i = n.get.text(); n.debug('Flashing text message', e, t), e = e || f.text.flash, t = t || f.flashDuration, a = a || function () {}, n.update.text(e), setTimeout(() => { n.update.text(i), a.call(w); }, t); } },
            reset: { text() {
              let e = m.active || y.data(g.storedText),
                t = m.inactive || y.data(g.storedText); n.is.textEnabled() && (n.is.active() && e ? (n.verbose('Resetting active text', e), n.update.text(e)) : t && (n.verbose('Resetting inactive text', e), n.update.text(t)));
            } },
            update: { text(e) { const t = n.get.text(); e && e !== t ? (n.debug('Updating text', e), f.selector.text ? y.data(g.storedText, e).find(f.selector.text).text(e) : y.data(g.storedText, e).html(e)) : n.debug('Text is already set, ignoring update', e); } },
            setting(t, i) { if (n.debug('Changing setting', t, i), e.isPlainObject(t))e.extend(!0, f, t); else { if (i === a) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], i) : f[t] = i; } },
            internal(t, i) { if (e.isPlainObject(t))e.extend(!0, n, t); else { if (i === a) return n[t]; n[t] = i; } },
            debug() { !f.silent && f.debug && (f.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), n.debug.apply(console, arguments))); },
            verbose() { !f.silent && f.verbose && f.debug && (f.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), n.verbose.apply(console, arguments))); },
            error() { f.silent || (n.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), n.error.apply(console, arguments)); },
            performance: { log(e) {
              let t,
                a; f.performance && (a = (t = (new Date()).getTime()) - (c || t), c = t, r.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: w, 'Execution Time': a })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
            },
              display() {
                let t = `${f.name}:`,
                  i = 0; c = !1, clearTimeout(n.performance.timer), e.each(r, (e, t) => { i += t['Execution Time']; }), t += ` ${i}ms`, s && (t += ` '${s}'`), (console.group !== a || console.table !== a) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), r = [];
              } },
            invoke(t, o, s) {
              let c,
                r,
                l,
                u = C; return o = o || d, s = w || s, typeof t === 'string' && u !== a && (t = t.split(/[\. ]/), c = t.length - 1, e.each(t, (i, o) => { const s = i != c ? o + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(u[s]) && i != c)u = u[s]; else { if (u[s] !== a) return r = u[s], !1; if (!e.isPlainObject(u[o]) || i == c) return u[o] !== a ? (r = u[o], !1) : (n.error(v.method, t), !1); u = u[o]; } })), e.isFunction(r) ? l = r.apply(s, o) : r !== a && (l = r), e.isArray(i) ? i.push(l) : i !== a ? i = [i, l] : l !== a && (i = l), r;
            } }, u ? (C === a && n.initialize(), n.invoke(l)) : (C !== a && C.invoke('destroy'), n.initialize());
      }), i !== a ? i : this;
  }, e.fn.state.settings = { name: 'State', debug: !1, verbose: !1, namespace: 'state', performance: !0, onActivate() {}, onDeactivate() {}, onChange() {}, activateTest() { return !0; }, deactivateTest() { return !0; }, automatic: !0, sync: !1, flashDuration: 1e3, filter: { text: '.loading, .disabled', active: '.disabled' }, context: !1, error: { beforeSend: 'The before send function has cancelled state change', method: 'The method you called is not defined.' }, metadata: { promise: 'promise', storedText: 'stored-text' }, className: { active: 'active', disabled: 'disabled', error: 'error', loading: 'loading', success: 'success', warning: 'warning' }, selector: { text: !1 }, defaults: { input: { disabled: !0, loading: !0, active: !0 }, button: { disabled: !0, loading: !0, active: !0 }, progress: { active: !0, success: !0, warning: !0, error: !0 } }, states: { active: !0, disabled: !0, error: !0, loading: !0, success: !0, warning: !0 }, text: { disabled: !1, flash: !1, hover: !1, active: !1, inactive: !1, activate: !1, deactivate: !1 } };
}(jQuery, window, document));
